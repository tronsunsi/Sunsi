

# TRX inscription Protocol 

This protocol represents a cutting-edge and experimental framework developed within the TRX (TRON) blockchain ecosystem. It introduces a novel method of data storage and tracking, fundamentally utilizing the memo field within TRX transactions. The cornerstone of this protocol is its unique approach to token identification and management, which diverges from traditional methods found in other blockchain systems.

# Detailed Components of the Protocol:
Data Storage and Memo Utilization:

# Innovative Use of Memo Field: 

The protocol leverages the memo field in TRX transactions as a primary medium for storing pertinent data. This data could range from transactional details to metadata associated with specific tokens or assets.
Dynamic Data Embedding: Each transaction becomes a carrier of information, embedding data dynamically within the blockchain.
Indexer-Based Tracking:

# Mints and Transfers Monitoring: 

A specialized indexer is deployed, functioning as the backbone for monitoring and tracking activities related to the minting of new tokens and the transfer of existing ones.
Real-Time Data Management: The indexer continuously scans, extracts, and processes data from transaction memos, ensuring real-time tracking and management of tokens.
Token Identification via Transaction Hash:

# Unique Identifier: 
In a departure from conventional token identifiers, this protocol employs the hash of each transaction as the unique identifier for tokens.
#Hash-Based Tokenization: 

This approach allows for a distinctive form of tokenization, where each transaction hash correlates to a specific token or asset within the ecosystem.
Minting Process and Black Hole Address:

# Symbolic TRX Transfer: 

The minting process involves transferring a nominal or inconsequential amount of TRX to a designated 'black hole' address. This process is akin to a token burn, effectively removing the TRX from circulation.
# Inscription of Data: 

Concurrently, the transaction carrying this TRX transfer inscribes data within its memo field, marking the creation or minting of a new token or asset.
Parallel to BTC Ordinals but with Distinct Mechanism:

# Inspiration from Bitcoin Ordinals: 

The system draws conceptual parallels to the ordinals found in the Bitcoin network.

# Distinct Operational Framework: 

However, it distinctively operates without actual ordinals, instead, basing its mechanism entirely on the unique hashes generated by each TRX transaction.
In summary, this highly experimental protocol on the TRX blockchain introduces a revolutionary approach to data storage and token management. It stands out by utilizing transaction hashes as unique identifiers for tokens and leveraging the memo field for data inscription. This system, while inspired by concepts from the Bitcoin network, charts its own course with a unique operational framework, emphasizing real-time data tracking and innovative token minting processes.


# Detailed Explanation:

# Core Mechanism:

# Data Storage: 

Each transaction embeds data within the memo field. This could be any relevant information, typically related to token metadata or transactional details.
Token Identification: The unique hash of each transaction, generated by the network, acts as the identifier for the tokens, akin to serial numbers.

# Functioning of Indexer:

# Tracking Transfers and Mints: 

A specialized indexer is in place to monitor, record, and manage the transactions specifically related to mints and transfers of these tokens.
Data Retrieval: The indexer extracts and deciphers data from the memo fields, linking it to the corresponding transaction hash.
Minting Process:

# TRX Consumption: 

A nominal or symbolic amount of TRX is sent to a designated 'black hole' address—a process akin to burning the currency.
Data Inscription: Along with this transaction, specific data is inscribed within the memo field, effectively minting a new token or inscription.
Comparison with BTC Ordinals:

# Adaptation and Differences: 

While drawing inspiration from the ordinals concept on Bitcoin, this protocol notably differs as it doesn’t use the ordinals but rather bases its uniqueness on the hash of each TRX transaction.


# Risks and Challenges with New Technology and Protocols:

# Technical Risks:

# Reliability of Indexer: 

The accuracy and reliability of the indexer are crucial. Any bugs or lapses in tracking can lead to loss of data integrity.

# Blockchain Limitations: 

The protocol's functionality is inherently tied to the TRX blockchain's capabilities and limitations, which could affect scalability and efficiency.

# Security Concerns:

# Transaction Hash Dependency: 

Relying on transaction hashes as unique identifiers bears risks, such as hash collisions or security vulnerabilities in hash generation.
Smart Contract Vulnerabilities: If smart contracts are used, they present a typical vector for attacks and need rigorous auditing and testing.

# Operational Challenges:

# Data Persistence: 

Ensuring that the inscribed data remains immutable and retrievable over time is a challenge, given the evolving nature of blockchain technologies.

# Network Congestion: 

High transaction volumes could lead to network congestion, affecting the minting and transfer processes.

Official Twitter:[@TronSuns](https://twitter.com/TronSuns)
Official Telegram:[@TronSuns](https://t.me/TronSuns)

## Token Economic
 - Token: $SUNSI
 - Supply: 2000000000


## Method
 - deploy: `data:,{"p":"trc-20","op":"deploy","tick":"sunsi","max":"2000000000"}`
 - mint: `data:,{"p":"trc-20","op":"mint","tick":"sunsi","amt":"1000","txid":UniqueTransactionIdentifier}`
 - transfer: `{
    "op": "transfer",
    "tick": "sunsi",
    "detail": [
        {"from": "Sender TRON Address", "to": "Recipient TRON Address", "amt": "1000"}
    ],
    "txid": "UniqueTransactionIdentifier"
}
`

## Deploy txid
https://tronscan.org/#/transaction/deb4d99057459c325ee2c3df6c1c2560eb6972368c882b4a5df493679ac39538

## Mint sunsi with nodejs
1. Install Node.js
2. Create a directory,such as `Mint`
3. Open `Mint`, execute command:`npm init`
4. Execute command:`npm install tronweb `
5. Create an index.js file,copy the code below
6. Run index.js:`node index.js` 

The mint process must inculde the payment hash or it cannot be comfirmed as unique or valid. 
```
const TronWeb = require('tronweb');
const HttpProvider = TronWeb.providers.HttpProvider;
const fullNode = new HttpProvider("https://api.trongrid.io");
const solidityNode = new HttpProvider("https://api.trongrid.io");
const eventServer = new HttpProvider("https://api.trongrid.io");
const privateKey = "your privateKey"; //
const tronWeb = new TronWeb(fullNode, solidityNode, eventServer, privateKey);

async function main() {

 const blackHole = "T9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb";  //black hole address

        var totalPrice = (totalMints * 0.002 ) * (10**6);
        const unSignedTxnPayment = await tronWeb.transactionBuilder.sendTrx("TUEVrvBWi7hpMCoDvUFkg8eSZ8MbQ7p8r3", totalPrice); 
        const memo = `data:,{"p":"trc-20","op":"mint","tick":"sunsi","amt":"${totalMints}",hash:"${unSignedTxnPayment.txID}"`;
        const unSignedTxnMint = await tronWeb.transactionBuilder.sendTrx(blackHole, 1); 
        const unSignedTxnWithNote = await tronWeb.transactionBuilder.addUpdateData(unSignedTxnMint, memo, 'utf8');
        const signedTxnPayment = await tronWeb.trx.sign(unSignedTxnPayment);
        const signedTxn = await tronWeb.trx.sign(unSignedTxnWithNote);
        const broadcast = await tronWeb.trx.sendRawTransaction(signedTxn);
        const broadcastPayment = await tronWeb.trx.sendRawTransaction(signedTxnPayment);
}

main().then(() => {

    })
    .catch((err) => {
        console.log("error:", err);
    });
```


